
  deepdive.db.default {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME}
    user: ${PGUSER}
    password: ${PGPASSWORD}
    dbname: ${DBNAME}
    host: ${PGHOST}
    port: ${PGPORT}
    incremental_mode: ORIGINAL
    }
    


      deepdive.schema.variables {
        a.label: Boolean
f.label: Boolean
e.label: Boolean
d.label: Boolean
c.label: Boolean
      }
    

          deepdive.extraction.extractors.init_e {
            sql: """ DROP TABLE IF EXISTS e CASCADE;
            CREATE TABLE
            e(k int,
 id bigint,
 label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_f {
            sql: """ DROP TABLE IF EXISTS f CASCADE;
            CREATE TABLE
            f(k int,
 id bigint,
 label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_a {
            sql: """ DROP TABLE IF EXISTS a CASCADE;
            CREATE TABLE
            a(k int,
 id bigint,
 label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_b {
            sql: """ DROP TABLE IF EXISTS b CASCADE;
            CREATE TABLE
            b(k int,
 p int,
 q text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_c {
            sql: """ DROP TABLE IF EXISTS c CASCADE;
            CREATE TABLE
            c(k int,
 id bigint,
 label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_d {
            sql: """ DROP TABLE IF EXISTS d CASCADE;
            CREATE TABLE
            d(k int,
 id bigint,
 label boolean)
            """
            style: "sql_extractor"
          }

        deepdive.extraction.extractors.cleanup {
          sql: """
          TRUNCATE e;
          TRUNCATE f;
          TRUNCATE a;
          TRUNCATE b;
          TRUNCATE c;
          TRUNCATE d;
          """
          style: "sql_extractor"
        }

        deepdive.inference.factors.inf_istrue_a {
          input_query: """
          SELECT R0.id AS "a.R0.id" , (R0.k + R1.p) AS "dd_weight_column_0" 
          FROM a R0, b R1
        WHERE R1.k = R0.k """
          function: "Imply(a.R0.label)"
          weight: "?(dd_weight_column_0)"
        }
      

        deepdive.inference.factors.inf_istrue_c {
          input_query: """
          SELECT R0.id AS "c.R0.id" 
          FROM c R0, b R1
        WHERE R1.k = R0.k """
          function: "Imply(c.R0.label)"
          weight: "?"
        }
      

        deepdive.inference.factors.inf_istrue_d {
          input_query: """
          SELECT R0.id AS "d.R0.id" , R0.k AS "dd_weight_column_0" , R1.p AS "dd_weight_column_1" 
          FROM d R0, b R1
        WHERE R1.k = R0.k """
          function: "Imply(d.R0.label)"
          weight: "?(dd_weight_column_0, dd_weight_column_1)"
        }
      

        deepdive.inference.factors.inf_istrue_e {
          input_query: """
          SELECT R0.id AS "e.R0.id" 
          FROM e R0, b R1
        WHERE R1.k = R0.k """
          function: "Imply(e.R0.label)"
          weight: "-10"
        }
      

        deepdive.inference.factors.inf_istrue_f {
          input_query: """
          SELECT R0.id AS "f.R0.id" 
          FROM f R0, b R1
        WHERE R1.k = R0.k """
          function: "Imply(f.R0.label)"
          weight: "-0.3"
        }
      
deepdive.pipeline.run: ${PIPELINE}
deepdive.pipeline.pipelines.initdb: [
  init_e
  init_f
  init_a
  init_b
  init_c
  init_d
]
deepdive.pipeline.pipelines.inference: [
  inf_istrue_a
  inf_istrue_c
  inf_istrue_d
  inf_istrue_e
  inf_istrue_f
]
deepdive.pipeline.pipelines.endtoend: [
  inf_istrue_a
  inf_istrue_c
  inf_istrue_d
  inf_istrue_e
  inf_istrue_f
]
deepdive.pipeline.pipelines.cleanup: [
  cleanup
]
